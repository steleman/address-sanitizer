#summary AddressSanitizer for Linux kernel.

= Introduction =

A dynamic memory error detector for Linux kernel.
Currently works on x86_64.

= Overview =

Currently the kernel has the following configs:

CONFIG_DEBUG_SLAB
 * Enables red-zoning and poisoning
 * Can detect some out-of-bounds (OOB) accesses and use-after-free (UAF)
 * Does not detect OOB reads
 * Best-effort UAF detection

CONFIG_KMEMCHECK - heavy-handed uninitialized memory access checker
 * Causes page-fault on every memory access
 * Slow

CONFIG_DEBUG_PAGEALLOC
 * Unmaps freed pages from address space
 * Can detect some UAF accesses
 * Detects UAF only when the whole page is unused

We are going to implement:

CONFIG_ASAN
 * Fast and comprehensive solution for UAF and OOB
 * Based on compiler instrumentation (fast)
 * OOB for both writes and reads
 * Strong UAF detection
 * Prompt detection of bad memory accesses
 * Informative reports

= Details =

Pre-alpha repository: https://github.com/xairy/linux

== Reports ==

To simplify reading the reports you can use our [https://code.google.com/p/address-sanitizer/source/browse/trunk/tools/kasan_symbolize.py symbolizer script]:
{{{
$ cat ./report
...
[    0.359730]   #0 ffffffff810d1964 (asan_slab_free+0x74/0xe0)
[    0.360016]   #1 ffffffff81262a3a (kfree+0x9a/0x240)
...
}}}
{{{
$ cat ./report | ./kasan_symbolize.py ./vmlinux
...
  #0 ffffffff810d1964 (asan_slab_free+0x74/0xe0) ./arch/x86/mm/asan/asan.c:134
  #1      inlined     (kfree+0x9a/0x240) virt_to_head_page ./include/linux/mm.h:420
  #1      inlined     (kfree+0x9a/0x240) virt_to_slab ./mm/slab.c:462
  #1      inlined     (kfree+0x9a/0x240) cache_free_alien ./mm/slab.c:1103
  #1      inlined     (kfree+0x9a/0x240) __cache_free ./mm/slab.c:3606
  #1 ffffffff81262a3a (kfree+0x9a/0x240) ./mm/slab.c:3830
...
}}}

== Algorithm ==

The description of the ASan algorithm for user-space applications can be found [https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm here].
In kernel-space we are tracking only the part of the virtual address space, which is directly mapped to the physical memory (0xffff880000000000 - 0xffffc7ffffffffff).

== Mapping ==

{{{
Shadow = ((Mem - PAGE_OFFSET) >> 3) + PAGE_OFFSET + SHADOW_OFFSET;
}}}
where:
{{{
PAGE_OFFSET   = 0xffff880000000000
SHADOW_OFFSET = 0x0000000036400600
}}}

== Instrumentation ==

To instrument the kernel gcc-tsan instrumentation is used, but it requires a slight modification.

Checkout gcc:
{{{
svn checkout -r 200953 svn://gcc.gnu.org/svn/gcc/trunk $GCC_KASAN
}}}

Apply the following patch:
{{{
Index: gcc/tsan.c
===================================================================
--- gcc/tsan.c	(revision 200953)
+++ gcc/tsan.c	(working copy)
@@ -702,8 +702,8 @@
   initialize_sanitizer_builtins ();
   if (instrument_memory_accesses ())
     {
-      instrument_func_entry ();
-      instrument_func_exit ();
+      //instrument_func_entry ();
+      //instrument_func_exit ();
     }
   return 0;
 }
@@ -724,11 +724,11 @@
   tree ctor_statements = NULL_TREE;
 
   initialize_sanitizer_builtins ();
-  tree init_decl = builtin_decl_implicit (BUILT_IN_TSAN_INIT);
-  append_to_statement_list (build_call_expr (init_decl, 0),
-			    &ctor_statements);
-  cgraph_build_static_cdtor ('I', ctor_statements,
-			     MAX_RESERVED_INIT_PRIORITY - 1);
+//  tree init_decl = builtin_decl_implicit (BUILT_IN_TSAN_INIT);
+//  append_to_statement_list (build_call_expr (init_decl, 0),
+//			    &ctor_statements);
+//  cgraph_build_static_cdtor ('I', ctor_statements,
+//			     MAX_RESERVED_INIT_PRIORITY - 1);
 }
 
 /* The pass descriptor.  */
}}}
to the gcc:
{{{
cd $GCC_KASAN
patch -p0 -i patch_name
}}}

Install gcc prerequisites:
{{{
sudo apt-get install flex bison libc6-dev libc6-dev-i386 libgmp3-dev libmpfr-dev libmpc-dev
}}}

Build gcc:
{{{
cd $GCC_KASAN
mkdir build
mkdir install
cd build
../configure --enable-languages=c,c++ --disable-bootstrap --enable-checking=no --with-gnu-as --with-gnu-ld --with-ld=/usr/bin/ld.bfd --prefix=$GCC_KASAN/install
make
make install
}}}

Set gcc path in the wrapper script linux/gcc.py:
{{{
gcc = '$GCC_KASAN/install/bin/gcc'
}}}

The kernel Makefile is changed so when you start building the kernel it will automatically use the wrapper script.


= Trophies =

*Fixed:*
 * Out-of-bounds read in net/ipv4:
http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aab515d7c32a34300312416c50314e755ea6f765
 * Out-of-bounds in get_wchan (arch/x86/kernel/process_64.c):
https://www.lkml.org/lkml/2013/9/3/286
 * Out-of-bounds in sd_revalidate_disk (drivers/scsi/sd.c):
http://www.spinics.net/lists/linux-scsi/msg68519.html

*Not confirmed:*
 * Use-after-free in drivers/net/ethernet/intel/e1000:
http://permalink.gmane.org/gmane.linux.drivers.e1000.devel/12441
 * Use-after-free in kernel/kmod:
https://www.lkml.org/lkml/2013/8/21/431
 * Out-of-bounds read in fs/dcache:
https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernelReports
 * Use-after-free in ext4_mb_new_blocks:
http://permalink.gmane.org/gmane.comp.file-systems.ext4/40353
 * Out-of-bounds in ip6_finish_output2:
http://www.spinics.net/lists/netdev/msg250734.html
 * Use-after-free in SyS_remap_file_pages:
https://lkml.org/lkml/2013/9/17/30
 * Use-after-free in aio_migratepage:
sent to  linux-aio mainling list, not visible on web, the report is here:
https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernelReports