#summary AddressSanitizer for Linux kernel.

= Introduction =

A dynamic memory error detector for Linux kernel.
Currently works on x86_64.

= Overview =

Currently the kernel has the following configs:

CONFIG_DEBUG_SLAB
 * Enables red-zoning and poisoning
 * Can detect some out-of-bounds (OOB) accesses and use-after-free (UAF)
 * Does not detect OOB reads
 * Best-effort UAF detection

CONFIG_KMEMCHECK - heavy-handed uninitialized memory access checker
 * Causes page-fault on every memory access
 * Slow

CONFIG_DEBUG_PAGEALLOC
 * Unmaps freed pages from address space
 * Can detect some UAF accesses
 * Detects UAF only when the whole page is unused

We are going to implement:

CONFIG_ASAN
 * Fast and comprehensive solution for UAF and OOB
 * Based on compiler instrumentation (fast)
 * OOB for both writes and reads
 * Strong UAF detection
 * Prompt detection of bad memory accesses
 * Informative reports

= Details =

Pre-alpha repository: https://github.com/xairy/linux

== Algorithm ==

The description of the ASan algorithm for user-space applications can be found [https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm here].
In kernel-space we are tracking only the part of the virtual address space, which is directly mapped to the physical memory (0xffff880000000000 - 0xffffc7ffffffffff).

== Mapping ==

{{{
Shadow = ((Mem - PAGE_OFFSET) >> 3) + PAGE_OFFSET + SHADOW_OFFSET;
}}}
where:
{{{
PAGE_OFFSET   = 0xffff880000000000
SHADOW_OFFSET = 0x0000000036400600
}}}

== Instrumentation ==

To instrument the kernel gcc-tsan instrumentation is used, but it requires a slight modification.

Checkout gcc:
{{{
svn checkout -r 200953 svn://gcc.gnu.org/svn/gcc/trunk $GCC_KASAN
}}}

Apply the following patch:
{{{
Index: gcc/tsan.c
===================================================================
--- gcc/tsan.c	(revision 200953)
+++ gcc/tsan.c	(working copy)
@@ -724,11 +724,11 @@
   tree ctor_statements = NULL_TREE;
 
   initialize_sanitizer_builtins ();
-  tree init_decl = builtin_decl_implicit (BUILT_IN_TSAN_INIT);
-  append_to_statement_list (build_call_expr (init_decl, 0),
-			    &ctor_statements);
-  cgraph_build_static_cdtor ('I', ctor_statements,
-			     MAX_RESERVED_INIT_PRIORITY - 1);
+//  tree init_decl = builtin_decl_implicit (BUILT_IN_TSAN_INIT);
+//  append_to_statement_list (build_call_expr (init_decl, 0),
+//			    &ctor_statements);
+//  cgraph_build_static_cdtor ('I', ctor_statements,
+//			     MAX_RESERVED_INIT_PRIORITY - 1);
 }
 
 /* The pass descriptor.  */
}}}
to the gcc:
{{{
cd $GCC_KASAN
patch -p0 -i patch_name
}}}

Install gcc prerequisites:
{{{
sudo apt-get install flex bison libc6-dev libc6-dev-i386 libgmp3-dev libmpfr-dev libmpc-dev
}}}

Build gcc:
{{{
cd $GCC_KASAN
mkdir build
mkdir install
cd build
../configure --enable-languages=c,c++ --disable-bootstrap --enable-checking=no --with-gnu-as --with-gnu-ld --with-ld=/usr/bin/ld.bfd --prefix=$GCC_KASAN/install
make
make install
}}}

Set gcc path in the wrapper script linux/gcc.py:
{{{
gcc = '$GCC_KASAN/install/bin/gcc'
}}}

The kernel Makefile is changed so when you start building the kernel it will automatically use the wrapper script.


= Trophies =

 * Out-of-bounds read in net/ipv4 (fixed):
http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aab515d7c32a34300312416c50314e755ea6f765
 * Use-after-free in drivers/net/ethernet/intel/e1000 (not confirmed):
http://permalink.gmane.org/gmane.linux.drivers.e1000.devel/12441
 * Use-after-free in kernel/kmod (not confirmed):
https://www.lkml.org/lkml/2013/8/21/431
 * Out-of-bounds read in fs/dcache:
http://lxr.free-electrons.com/source/fs/dcache.c#L156