#summary This page describes the level of AddressSanitizer run-time and compiler support for various platforms

<wiki:toc max_depth="2" />


=Platforms=
== x86/x86_64 Linux ==
Just works, this is the primary platforms for the developers. 

Stack unwinding: frame pointers. <BR>
Default shadow mapping: 
{{{
Shadow = (Mem >> 3) | 0x20000000         # 32 bit
Shadow = (Mem >> 3) | 0x0000100000000000 # 64 bit
}}}
Alternative shadow mapping, requires -pie
{{{
Shadow = Mem >> 3         # 32 and 64 bit
}}}
Function interception: `dlsym`


== x86/x86_64 Darwin (OSX) ==
Just works, but the machinery used to intercept functions (mach_override) may soon be replaced with another one (function interposition)

Stack unwinding: frame pointers. <BR>
Shadow mapping: 
{{{
Shadow = (Mem >> 3) | 0x20000000         # 32 bit
Shadow = (Mem >> 3) | 0x0000100000000000 # 64 bit
}}}


== ARM Android ==
Works (TODO(eugenis))

Stack unwinding mechanism: `_Unwind_Backtrace`. <BR>

== ARM iOS ==
Doing baby steps, help is welcome.

== x86 Windows== 
C-only code mostly works,<br>
Simple C++ code also works, complex C++ code using multiple/virtual inheritance doesn't work.<br>
See issue 56 for the details.<br>
Help is welcome!

Stack unwinding mechanism: `CaptureStackBackTrace` <BR>

== PowerPC32/PowerPC64 Linux == 
We've been notified that small tests work. 
TODO: describe the differences (e.g. the shadow mapping, offset, page size, etc)

Stack unwinding mechanism: `_Unwind_Backtrace`. <BR>

== SPARC Linux == 
The run-time library is known to build on SPARC Linux. 

=Compilers= 
==Clang/LLVM==
Just works, this is the primary compiler for the developers. 

==GCC==
The first version is in trunk, will appear in 4.8 release. 
The implementation is (almost?) complete, but we don't have enough experience with it yet. 

In AddressSanitizer mode GCC defines `__SANITIZE_ADDRESS__` macro, but does not support `__has_feature(address_sanitizer)`