#summary The status of the common transformation project.

= Temporary repositories =

https://github.com/otinn/llvm

https://github.com/otinn/clang

https://github.com/otinn/memory-safety-testing-utils

= Initial results =
|| bench          || num loads/stores || num optimized by opt1 || num optimized by opt2 || num optimized by opt3 || num optimized total || run-time checks before opt || run-time checks avoided ||
|| 401.bzip2      || 4157             || 167 (4%)              || 1334 (32%)            || 30 (1%)               || 1531 (37%)          || 10526244748                || 5514284227 (52%) ||
|| 429.mcf        || 559              || 38 (7%)               || 61 (11%)              || 2 (0%)                || 101 (18%)           || 1458123364                 || 237088293 (16%) ||
|| 433.milc       || 4550             || 666 (15%)             || 338 (7%)              || 0 (0%)                || 1004 (22%)          || 13522033249                || 3086602745 (23%) ||
|| 445.gobmk      || 23876            || 4357 (18%)            || 3155 (13%)            || 411 (2%)              || 7923 (33%)          || 19325263713                || 8205893064 (42%) ||
|| 456.hmmer      || 12391            || 1146 (9%)             || 1456 (12%)            || 27 (0%)               || 2629 (21%)          || 4904909455                 || 221111686 (5%) ||
|| 458.sjeng      || 5051             || 852 (17%)             || 399 (8%)              || 21 (0%)               || 1272 (25%)          || 3811134741                 || 595197870 (16%) ||
|| 462.libquantum || 1029             || 418 (41%)             || 51 (5%)               || 0 (0%)                || 469 (46%)           || 1616295534                 || 294378970 (18%) ||
|| 464.h264ref    || 32248            || 3098 (10%)            || 2960 (9%)             || 133 (0%)              || 6191 (19%)          || 28132170266                || 7325970456 (26%) ||
|| 470.lbm        || 365              || 35 (10%)              || 24 (7%)               || 0 (0%)                || 59 (16%)            || 1432961919                 || 289561808 (20%) ||
|| all            || 84226            || 10777 (13%)           || 9778 (12%)            || 624 (1%)              || 21179 (25%)         || 84729136989                || 25770089119 (30%) ||

== opt1 (optimize-fast-memory-checks) ==
This pass removes fast load/store checks (ones where the memory object is known and valid at the time of the check) if it can prove that the access is entirely inside the memory object.

{{{
// This file shows examples of optimize-fast-memory-checks being applied.
// The code is from 456.hmmer/src/mathsupport.c with the define statements from
// the corresponding config.h
#include "math.h"

#define INTSCALE    1000.0   /* scaling constant for floats to integer scores */
#define LOGSUM_TBL  20000    /* controls precision of ILogsum()               */

static int ilogsum_lookup[LOGSUM_TBL];
static void 
init_ilogsum(void)
{
  int i;
  // The fast load check into ilogsum_lookup will be optimized away by
  // optimize-fast-memory-checks because it can prove that all of the accesses
  // in the loop are always in bounds.
  for (i = 0; i < LOGSUM_TBL; i++) 
    ilogsum_lookup[i] = (int) (INTSCALE * 1.44269504 * 
           (log(1.+exp(0.69314718 * (float) -i/INTSCALE))));
}
int 
ILogsum(int p1, int p2)
{
  int    diff;
  static int firsttime = 1;
  // The firsttime variable will become a global variable and get a fast load
  // check for the if-condition and a fast store check for the later assignment.
  // Both of the checks will be optimized away by optimize-fast-memory-checks
  // because they are obviously in bounds.
  if (firsttime) { init_ilogsum(); firsttime = 0; }

  diff = p1-p2;
  if      (diff >=  LOGSUM_TBL) return p1;
  else if (diff <= -LOGSUM_TBL) return p2;
  else if (diff > 0)            return p1 + ilogsum_lookup[diff];
  else                          return p2 + ilogsum_lookup[-diff];
  // The preceding two loads from ilogsum_lookup get fast load checks because
  // the underlying memory object is easily identifiable.
  // The checks are currently not optimized away because the analysis passes
  // can't prove that they will always be in bounds.
}

}}}

== opt2 (optimize-identical-ls-checks) ==
This pass removes identical load/store checks that appear in the same basic block.
It works by iterating over the calls in a basic block.
If any call is encountered then one of three things happens:
1) It is a load/store check with a previously unseen access pointer and size pair. The pair is added to the known accesses cache.
2) It is a load/store check with a previously seen access pointer and size pair. The check is removed.
3) It is another call that is not in a whitelist of functions known to not deallocate memory. The known access cache is cleared.

{{{
// This file shows an example of optimize-identical-ls-checks being applied.
// The code is from 401.bzip2/src/spec.c.

long int seedi;
double ran()
/* See "Random Number Generators: Good Ones Are Hard To Find", */
/*     Park & Miller, CACM 31#10 October 1988 pages 1192-1201. */
/***********************************************************/
/* THIS IMPLEMENTATION REQUIRES AT LEAST 32 BIT INTEGERS ! */
/***********************************************************/
#define _A_MULTIPLIER  16807L
#define _M_MODULUS     2147483647L /* (2**31)-1 */
#define _Q_QUOTIENT    127773L     /* 2147483647 / 16807 */
#define _R_REMAINDER   2836L       /* 2147483647 % 16807 */
{
  long lo;
  long hi;
  long test;

  // A load check will be inserted before the load from seedi.
  // It will not be converted into a fast check because it has common linkage.
  // Thus the check here will not be optimized away.
  hi = seedi / _Q_QUOTIENT;
  lo = seedi % _Q_QUOTIENT;
  test = _A_MULTIPLIER * lo - _R_REMAINDER * hi;

  // A store check will be inserted before the store into seedi.
  // It will not become a fast check for the same reason as the load check.
  // It will be optimized away by optimize-identical-ls-checks because it can
  // fail only if the load check does.
  if (test > 0) {
    seedi = test;
  } else {
    seedi = test + _M_MODULUS;
  }
  return ( (float) seedi / _M_MODULUS);
}
}}}

== opt3 (optimize-implied-fast-ls-checks) ==
This pass removes fast load/store checks that are implied by other fast load/store checks.
It works by traversing a dominator tree to find out which checks must always happen before other checks.
It removes fast load/store checks that are dominated by another fast load/store check with the same access offset, access size, and object size triple.

{{{
// This file shows an example of optimize-implied-fast-ls-checks being applied.
// The code is from 429.mcf/src/pbeampp.c with some definitions from the
// corresponding defines.h

typedef long flow_t;
typedef long cost_t;

typedef struct node *node_p;

typedef struct arc arc_t;
typedef struct arc *arc_p;

struct node
{
  cost_t potential; 
  int orientation;
  node_p child;
  node_p pred;
  node_p sibling;
  node_p sibling_prev;     
  arc_p basic_arc; 
  arc_p firstout, firstin;
  arc_p arc_tmp;
  flow_t flow;
  long depth; 
  int number;
  int time;
};

struct arc
{
  cost_t cost;
  node_p tail, head;
  int ident;
  arc_p nextout, nextin;
  flow_t flow;
  cost_t org_cost;
};

#define K 300
#define B  50

typedef struct basket
{
    arc_t *a;
    cost_t cost;
    cost_t abs_cost;
} BASKET;

static long basket_size;
static BASKET basket[B+K+1];
static BASKET *perm[B+K+1];

#ifdef _PROTO_
void sort_basket( long min, long max )
#else
void sort_basket( min, max )
    long min, max;
#endif
{
    long l, r;
    cost_t cut;
    BASKET *xchange;

    l = min; r = max;

    // The array access will get a fast load check that can't be optimized away
    // because the function could be called with parameters that would make this
    // check fail.
    // The load from the BASKET element will get a load check. It will not be
    // converted into a fast check because it will depend on the previous load.
    cut = perm[ (long)( (l+r) / 2 ) ]->abs_cost;

    do
    {
        // Both of the loops will get a similar check pair as the previous case.
        while( perm[l]->abs_cost > cut )
            l++;
        while( cut > perm[r]->abs_cost )
            r--;
            
        if( l < r )
        {
            // The loads on the right side will be avoided by reusing the data
            // from the while loops so there will be no load checks here.
            xchange = perm[l];
            // This array access will get a fast store check that will be
            // optimized away by optimize-implied-fast-ls-checks because it can
            // only fail if the fast load check in the first while loop fails.
            perm[l] = perm[r];
            // Same as the previous check except that it is caused by the fast
            // load check in the second while loop.
            perm[r] = xchange;
        }
        if( l <= r )
        {
            l++; r--;
        }

    }
    while( l <= r );

    if( min < r )
        sort_basket( min, r );
    if( l < max && l <= B )
        sort_basket( l, max ); 
}
}}}


= Interface =
{{{
// added before every load
void __loadcheck(void *ptr, size_t size);
void __fastloadcheck(void *ptr, size_t size, void *obj, size_t obj_size);

// added before every store
void __storecheck(void *ptr, size_t size);
void __faststorecheck(void *ptr, size_t size, void *obj, size_t obj_size);

// called when a fast load/store check has been inlined and fails
void __fail_fastloadcheck(void *ptr, size_t size, void *obj, size_t obj_size);
void __fail_faststorecheck(void *ptr, size_t size, void *obj, size_t obj_size);

// added after every gep; retuns a checked dest pointer (possibly a trap address)
void* __gepcheck(void *src, void *dest);
void* __fastgepcheck(void *src, void *dest, void *obj, size_t obj_size);

// added before every call through a function pointer
void __funccheck(void *func);

// added before every free
void __freecheck(void *ptr);

// added after every alloca instruction (or the whole stack if they are in a super-alloca)
void __pool_register_stack(void *obj, size_t obj_size);
// added before every return from a function for every existing __pool_register_stack
void __pool_unregister_stack(void *obj);

// added for every global in a special function, registers all globals and their sizes
void __pool_register_global(void *obj, size_t obj_size);

// added after every allocation on the heap (for example malloc); excludes realloc-like allocation
void __pool_register_heap(void *obj, size_t obj_size);
// added after the deallocation of every a heap object
void __pool_unregister_heap(void *obj);

// added after every realloc-like allocation on the heap
void __pool_reregister_heap(void *old_obj, void *new_obj, size_t new_size);
}}}

= Independently unnecessary load/store checks partitions = 
{{{
1. index problem
1.1. none
1.2. access starts before the object
1.3. access ends after the object

2. allocation problem
2.1. none
2.2. possibly freed
2.3. unknown allocation

3. index type
3.1. constant
3.2. simple expression (which limitations apply?)
3.3. anything else

4. object size type
4.1. constant
4.2. simple expression (which limitations apply?)
4.3. anything else

5. number of objects
5.1. single object
5.2. multiple objects

6. number of object types
6.1. one type
6.2. two or more types

7. number of object sizes
7.1. one size
7.2. two or more sizes

8. reason for multiple objects
8.1. N/A: one object
8.2. select
8.3. phi
8.4. mixed

9. loop structure
9.1. none
9.2. single loop
9.3. multiple loops
}}}

= Partitions for load/store checks that may be implied by other such checks =
{{{
1. index problem 
1.1. none
1.2. off in the same direction
1.3. off in different directions

2. allocation problem
2.1. none
2.2. first check on a possibly freed object
2.3. last check on a possibly freed object
2.4. both checks on a possibly freed object

3. boundary expression type
3.1. constant
3.2. simple expression (which limitations apply?)
3.3. unknown
3.4. anything else

4. number of memory object sets
4.1. one
4.2. two

5. CFG structure
5.1. same basic block
5.2. single connecting path
5.3. multiple connecting paths

6. loop structure
6.1. none
6.2. checks in the same loop
6.3. checks in different loops / one not in a loop
}}}

= Partitions for load/store/gep checks that can be converted to their fast versions =
{{{
1. allocation type
1.1. regular stack
1.2. scoped alloca
1.3. global
1.4. heap
1.5. mixed
1.6. unknown

2. allocation problem
2.1. none
2.2. possibly freed
2.3. possible to override global variable's size

3. object size type
3.1. constant
3.2. variable
3.3. unknown

4. number of objects
4.1. single object
4.2. multiple objects

5. number of object types
5.1. one type
5.2. two or more types

6. number of object sizes
6.1. one size
6.2. two or more sizes

7. reason for multiple objects
7.1. N/A: one object
7.2. select
7.3. phi
7.4. mixed

8. loop structure
8.1. none
8.2. single loop
8.3. multiple loops

9. CFG structure
9.1. same basic block
9.2. single connecting path
9.3. multiple connecting paths
}}}