#summary The status of the common transformation project.

= Temporary repositories =

https://github.com/otinn/llvm

https://github.com/otinn/clang

https://github.com/otinn/memory-safety-testing-utils

= Status =
Working on a pass to remove load/store checks implied by other checks.

= Interface =
{{{
// added before every load
void __loadcheck(void *ptr, size_t size);
void __fastloadcheck(void *ptr, size_t size, void *obj, size_t obj_size);

// added before every store
void __storecheck(void *ptr, size_t size);
void __faststorecheck(void *ptr, size_t size, void *obj, size_t obj_size);

// called when a fast load/store check has been inlined and fails
void __fail_fastloadcheck(void *ptr, size_t size, void *obj, size_t obj_size);
void __fail_faststorecheck(void *ptr, size_t size, void *obj, size_t obj_size);

// added after every gep; retuns a checked dest pointer (possibly a trap address)
void* __gepcheck(void *src, void *dest);
void* __fastgepcheck(void *src, void *dest, void *obj, size_t obj_size);

// added before every call through a function pointer
void __funccheck(void *func);

// added before every free
void __freecheck(void *ptr);

// added after every alloca instruction (or the whole stack if they are in a super-alloca)
void __pool_register_stack(void *obj, size_t obj_size);
// added before every return from a function for every existing __pool_register_stack
void __pool_unregister_stack(void *obj);

// added for every global in a special function, registers all globals and their sizes
void __pool_register_global(void *obj, size_t obj_size);

// added after every allocation on the heap (for example malloc); excludes realloc-like allocation
void __pool_register_heap(void *obj, size_t obj_size);
// added after the deallocation of every a heap object
void __pool_unregister_heap(void *obj);

// added after every realloc-like allocation on the heap
void __pool_reregister_heap(void *old_obj, void *new_obj, size_t new_size);
}}}

= Independently unnecessary load/store checks partitions = 
{{{
1. index problem
1.1. none
1.2. access starts before the object
1.3. access ends after the object

2. allocation problem
2.1. none
2.2. possibly freed
2.3. unknown allocation

3. index type
3.1. constant
3.2. simple expression (which limitations apply?)
3.3. anything else

4. object size type
4.1. constant
4.2. simple expression (which limitations apply?)
4.3. anything else

5. number of objects
5.1. single object
5.2. multiple objects

6. number of object types
6.1. one type
6.2. two or more types

7. number of object sizes
7.1. one size
7.2. two or more sizes

8. reason for multiple objects
8.1. N/A: one object
8.2. select
8.3. phi
8.4. mixed

9. loop structure
9.1. none
9.2. single loop
9.3. multiple loops
}}}

= Partitions for load/store checks that may be implied by other such checks =
{{{
1. index problem 
1.1. none
1.2. off in the same direction
1.3. off in different directions

2. allocation problem
2.1. none
2.2. first check on a possibly freed object
2.3. last check on a possibly freed object
2.4. both checks on a possibly freed object

3. boundary expression type
3.1. constant
3.2. simple expression (which limitations apply?)
3.3. unknown
3.4. anything else

4. number of memory object sets
4.1. one
4.2. two

5. CFG structure
5.1. same basic block
5.2. single connecting path
5.3. multiple connecting paths

6. loop structure
6.1. none
6.2. checks in the same loop
6.3. checks in different loops / one not in a loop
}}}

= Partitions for load/store/gep checks that can be converted to their fast versions =
{{{
1. allocation type
1.1. regular stack
1.2. scoped alloca
1.3. global
1.4. heap
1.5. mixed
1.6. unknown

2. allocation problem
2.1. none
2.2. possibly freed
2.3. possible to override global variable's size

3. object size type
3.1. constant
3.2. variable
3.3. unknown

4. number of objects
4.1. single object
4.2. multiple objects

5. number of object types
5.1. one type
5.2. two or more types

6. number of object sizes
6.1. one size
6.2. two or more sizes

7. reason for multiple objects
7.1. N/A: one object
7.2. select
7.3. phi
7.4. mixed

8. loop structure
8.1. none
8.2. single loop
8.3. multiple loops

9. CFG structure
9.1. same basic block
9.2. single connecting path
9.3. multiple connecting paths
}}}