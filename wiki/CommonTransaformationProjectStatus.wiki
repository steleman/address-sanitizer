#summary The common memory safety instrumentation/optimization project.

<wiki:toc max_depth="2" />

The goal of this project was to create memory safety instrumentation and optimization passes that could be used by different memory error detection systems. The general idea is to add checks before operations that may cause invalid memory accesses. Passes were also added to register memory objects becoming valid/invalid.

Having similar checks and registration calls makes it possible to use the same optimization passes to avoid unnecessary checks and variable registrations at run-time. The important ones for ASan are the following:
  * Load and store checks. These are inserted before all load/store instructions and other memory accessing intrinsics.
  * Fast load and store checks. These are load/store checks where the memory object is known and it is only necessary to compare the access boundaries to the object boundaries to know whether it is valid. They are useful because it is easier to optimize them away.
  * Global and stack variable registration calls. Knowing that it will not be necessary to know about some of these memory objects to find out whether the load/store checks are valid makes it possible for ASan to avoid poisoning the memory around them.

= Results =
The optimizations opt1-3 are described after the tables.
|| bench          || num loads/stores || num optimized by opt1 || num optimized by opt2 || num optimized by opt3 || num optimized total || run-time checks before opt || run-time checks avoided ||
|| 401.bzip2      || 4157             || 167 (4%)              || 1334 (32%)            || 30 (1%)               || 1531 (37%)          || 10526244748                || 5514284227 (52%) ||
|| 429.mcf        || 559              || 38 (7%)               || 61 (11%)              || 2 (0%)                || 101 (18%)           || 1458123364                 || 237088293 (16%) ||
|| 433.milc       || 4550             || 666 (15%)             || 338 (7%)              || 0 (0%)                || 1004 (22%)          || 13522033249                || 3086602745 (23%) ||
|| 445.gobmk      || 23876            || 4357 (18%)            || 3155 (13%)            || 411 (2%)              || 7923 (33%)          || 19325263713                || 8205893064 (42%) ||
|| 456.hmmer      || 12391            || 1146 (9%)             || 1456 (12%)            || 27 (0%)               || 2629 (21%)          || 4904909455                 || 221111686 (5%) ||
|| 458.sjeng      || 5051             || 852 (17%)             || 399 (8%)              || 21 (0%)               || 1272 (25%)          || 3811134741                 || 595197870 (16%) ||
|| 462.libquantum || 1029             || 418 (41%)             || 51 (5%)               || 0 (0%)                || 469 (46%)           || 1616295534                 || 294378970 (18%) ||
|| 464.h264ref    || 32238            || 3098 (10%)            || 2960 (9%)             || 133 (0%)              || 6191 (19%)          || 28132170266                || 7325970456 (26%) ||
|| 470.lbm        || 365              || 35 (10%)              || 24 (7%)               || 0 (0%)                || 59 (16%)            || 1432961919                 || 289561808 (20%) ||
|| all            || 84216            || 10777 (13%)           || 9778 (12%)            || 624 (1%)              || 21179 (25%)         || 84729136989                || 25770089119 (30%) ||

= Results vs. ASan Optimizations =
This table shows the comparison between the optimizations already in ASan compared to adding the new optimizations. Note that the first run-time check column excludes the ones already avoided by ASan and the second one compares to the ASan results, not the completely unoptimized ones.
|| bench          || num loads/stores || num optimized by ASan (incl. opt2) || num optimized by opt1 || num optimized by opt3 || num optimized total || run-time checks with ASan || extra run-time checks avoided ||
|| 401.bzip2      || 4157             || 1397 (34%)                         || 117 (3%)              || 30 (1%)               || 1544 (37%)          || 5137561629                || 125601112 (2%) ||
|| 429.mcf        || 559              || 64 (11%)                           || 35 (6%)               || 2 (0%)                || 101 (18%)           || 1347470725                || 126435654 (9%) ||
|| 433.milc       || 4550             || 376 (8%)                           || 628 (14%)             || 0 (0%)                || 1004 (22%)          || 10445237743               || 9807239 (0%) ||
|| 445.gobmk      || 23876            || 4155 (17%)                         || 3357 (14%)            || 411 (2%)              || 7923 (33%)          || 13277021610               || 2157650961 (16%) ||
|| 456.hmmer      || 12391            || 1658 (13%)                         || 944 (8%)              || 27 (0%)               || 2629 (21%)          || 4841867418                || 158069649 (3%) ||
|| 458.sjeng      || 5051             || 518 (10%)                          || 736 (15%)             || 21 (0%)               || 1275 (25%)          || 3450070076                || 234133230 (7%) ||
|| 462.libquantum || 1029             || 195 (19%)                          || 274 (27%)             || 0 (0%)                || 469 (46%)           || 1330597100                || 8680536 (1%) ||
|| 464.h264ref    || 32238            || 3182 (10%)                         || 2880 (9%)             || 133 (0%)              || 6195 (19%)          || 27806106226               || 7000682956 (25%) ||
|| 470.lbm        || 365              || 29 (8%)                            || 30 (8%)               || 0 (0%)                || 59 (16%)            || 1143400226                || 115 (0%) ||
|| all            || 84216            || 11574 (14%)                        || 9001 (11%)            || 624 (1%)              || 21199 (25%)         || 68779332753               || 9821061452 (14%) ||

= Load/store Check Optimizations =
== opt1 (optimize-fast-memory-checks) ==
This pass removes fast load/store checks (ones where the memory object is known and valid at the time of the check) if it can prove that the access is entirely inside the memory object. It uses the array bounds analysis group to do so.

This pass can handle the following:
  * Cases where a gep indexes into an object using constant indices (this subsumes the ASan global scalar optimization).
  * Some cases where the previous case is complicated by the select and/or phi instructions that select the gep to use.
  * Some cases where the gep depends on loop induction variables. [https://github.com/otinn/llvm/blob/master/test/Instrumentation/MemorySafety/optimization/always_valid/0039.ll (example)]

{{{
// This file shows examples of optimize-fast-memory-checks being applied.
// The code is from 456.hmmer/src/mathsupport.c with the define statements from
// the corresponding config.h
#include "math.h"

#define INTSCALE    1000.0   /* scaling constant for floats to integer scores */
#define LOGSUM_TBL  20000    /* controls precision of ILogsum()               */

static int ilogsum_lookup[LOGSUM_TBL];
static void 
init_ilogsum(void)
{
  int i;
  // The fast load check into ilogsum_lookup will be optimized away by
  // optimize-fast-memory-checks because it can prove that all of the accesses
  // in the loop are always in bounds.
  for (i = 0; i < LOGSUM_TBL; i++) 
    ilogsum_lookup[i] = (int) (INTSCALE * 1.44269504 * 
           (log(1.+exp(0.69314718 * (float) -i/INTSCALE))));
}
int 
ILogsum(int p1, int p2)
{
  int    diff;
  static int firsttime = 1;
  // The firsttime variable will become a global variable and get a fast load
  // check for the if-condition and a fast store check for the later assignment.
  // Both of the checks will be optimized away by optimize-fast-memory-checks
  // because they are obviously in bounds.
  if (firsttime) { init_ilogsum(); firsttime = 0; }

  diff = p1-p2;
  if      (diff >=  LOGSUM_TBL) return p1;
  else if (diff <= -LOGSUM_TBL) return p2;
  else if (diff > 0)            return p1 + ilogsum_lookup[diff];
  else                          return p2 + ilogsum_lookup[-diff];
  // The preceding two loads from ilogsum_lookup get fast load checks because
  // the underlying memory object is easily identifiable.
  // The checks are currently not optimized away because the analysis passes
  // can't prove that they will always be in bounds.
}

}}}

== opt2 (optimize-identical-ls-checks) ==
This pass removes identical load/store checks that appear in the same basic block.
It works by iterating over the calls in a basic block.
If any call is encountered then one of three things happens:
1) It is a load/store check with a previously unseen access pointer and size pair. The pair is added to the known accesses cache.
2) It is a load/store check with a previously seen access pointer and size pair. The check is removed.
3) It is another call that is not in a whitelist of functions known to not deallocate memory. The known access cache is cleared.

The same behaviour already exists in ASan.

{{{
// This file shows an example of optimize-identical-ls-checks being applied.
// The code is from 401.bzip2/src/spec.c.

long int seedi;
double ran()
/* See "Random Number Generators: Good Ones Are Hard To Find", */
/*     Park & Miller, CACM 31#10 October 1988 pages 1192-1201. */
/***********************************************************/
/* THIS IMPLEMENTATION REQUIRES AT LEAST 32 BIT INTEGERS ! */
/***********************************************************/
#define _A_MULTIPLIER  16807L
#define _M_MODULUS     2147483647L /* (2**31)-1 */
#define _Q_QUOTIENT    127773L     /* 2147483647 / 16807 */
#define _R_REMAINDER   2836L       /* 2147483647 % 16807 */
{
  long lo;
  long hi;
  long test;

  // A load check will be inserted before the load from seedi.
  // It will not be converted into a fast check because it has common linkage.
  // Thus the check here will not be optimized away.
  hi = seedi / _Q_QUOTIENT;
  lo = seedi % _Q_QUOTIENT;
  test = _A_MULTIPLIER * lo - _R_REMAINDER * hi;

  // A store check will be inserted before the store into seedi.
  // It will not become a fast check for the same reason as the load check.
  // It will be optimized away by optimize-identical-ls-checks because it can
  // fail only if the load check does.
  if (test > 0) {
    seedi = test;
  } else {
    seedi = test + _M_MODULUS;
  }
  return ( (float) seedi / _M_MODULUS);
}
}}}

== opt3 (optimize-implied-fast-ls-checks) ==
This pass removes fast load/store checks that are implied by other fast load/store checks.
It works by traversing a dominator tree to find out which checks must always happen before other checks.
It removes fast load/store checks that are dominated by another fast load/store check with the same access offset, access size, and object size triple.

{{{
// This file shows an example of optimize-implied-fast-ls-checks being applied.
// The code is from 429.mcf/src/pbeampp.c with some definitions from the
// corresponding defines.h

typedef long flow_t;
typedef long cost_t;

typedef struct node *node_p;

typedef struct arc arc_t;
typedef struct arc *arc_p;

struct node
{
  cost_t potential; 
  int orientation;
  node_p child;
  node_p pred;
  node_p sibling;
  node_p sibling_prev;     
  arc_p basic_arc; 
  arc_p firstout, firstin;
  arc_p arc_tmp;
  flow_t flow;
  long depth; 
  int number;
  int time;
};

struct arc
{
  cost_t cost;
  node_p tail, head;
  int ident;
  arc_p nextout, nextin;
  flow_t flow;
  cost_t org_cost;
};

#define K 300
#define B  50

typedef struct basket
{
    arc_t *a;
    cost_t cost;
    cost_t abs_cost;
} BASKET;

static long basket_size;
static BASKET basket[B+K+1];
static BASKET *perm[B+K+1];

#ifdef _PROTO_
void sort_basket( long min, long max )
#else
void sort_basket( min, max )
    long min, max;
#endif
{
    long l, r;
    cost_t cut;
    BASKET *xchange;

    l = min; r = max;

    // The array access will get a fast load check that can't be optimized away
    // because the function could be called with parameters that would make this
    // check fail.
    // The load from the BASKET element will get a load check. It will not be
    // converted into a fast check because it will depend on the previous load.
    cut = perm[ (long)( (l+r) / 2 ) ]->abs_cost;

    do
    {
        // Both of the loops will get a similar check pair as the previous case.
        while( perm[l]->abs_cost > cut )
            l++;
        while( cut > perm[r]->abs_cost )
            r--;
            
        if( l < r )
        {
            // The loads on the right side will be avoided by reusing the data
            // from the while loops so there will be no load checks here.
            xchange = perm[l];
            // This array access will get a fast store check that will be
            // optimized away by optimize-implied-fast-ls-checks because it can
            // only fail if the fast load check in the first while loop fails.
            perm[l] = perm[r];
            // Same as the previous check except that it is caused by the fast
            // load check in the second while loop.
            perm[r] = xchange;
        }
        if( l <= r )
        {
            l++; r--;
        }

    }
    while( l <= r );

    if( min < r )
        sort_basket( min, r );
    if( l < max && l <= B )
        sort_basket( l, max ); 
}
}}}

= The Code =

The code is available in the modified LLVM and Clang repositories linked below. It works with unmodified compiler-rt.

https://github.com/otinn/llvm

https://github.com/otinn/clang

https://github.com/otinn/compiler-rt (unmodified but should always contain a version that works with the modified LLVM and Clang)

Some testing utilities are in this repository:

https://github.com/otinn/memory-safety-testing-utils