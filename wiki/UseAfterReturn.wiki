#summary Detecting stack-use-after-return bugs

= Introduction =

*Stack-use-after-return* bug appears when a stack object is used after
the function where this object is defined has returned.
Example (see also ExampleUseAfterReturn):
{{{
int *ptr;
void FunctionThatEscapesLocalObject() {
  int local[100];
  ptr = &local[0];
}
// *ptr is used later
}}}

AddressSanitizer currently does not attempt to detect these bugs by default,
only with an additional flag: -fsanitize=use-after-return (Clang only)

=Algorithm=
Detection of stack-use-after-return is similar to detection of heap-use-after-free,
but the *quarantine* should be implemented in a different way.

Once a function has returned, its stack memory is reused by the next call instruction.
So in order to implemented quarantine for the stack memory we need to promote stack to heap.
The current implementation does it like this:

Before:
{{{
void foo() {
  int local;
  escape_addr(&local);
}
}}}
After:
{{{
void foo() {
  char redzone1[32];
  int local;
  char redzone2[32+28];
  char *fake_stack = __asan_stack_malloc(&local, 96);
  poison_redzones(fake_stack);  // Done by the inlined instrumentation code.
  escape_addr(fake_stack + 32);
  __asan_stack_free(stack, &local, 96)
}
}}}

*`__asan_stack_malloc(real_stack, frame_size)`* allocates a *fake frame*
(`frame_size` bytes) from a thread-local heap-like structure (*fake stack*)`.
The currently allocated fake frames are organized in a LIFO (stack) data structure.
Every frame remembers the `real_stack` associated with it.
Based on the value of current `real_stack` all retired stack frames are 
popped from the LIFO and deallocated.
Deallocated stack frames are put into a FIFO data structure (quarantine).
Every fake frame comes unpoisoned and then the redzones are poisoned in the instrumented
function code.

*`__asan_stack_free(fake_stack, real_stack, frame_size)`* poisons the entire fake frame.
It does not update fake stack data structures. Generally, we can not rely
on `__asan_stack_free` being called at the end of the function
(due to exceptions, longjmp and other "never-return" statements).

=Performance=
Detecting stack-use-after-return is expensive in both CPU and RAM:
  * Allocating fake frames introduces two function calls per every function with non-empty frame.
  * The entire fake frames should be unpoisoned on entry and poisoned on exit, as opposed to poisoning just the redzones in the default mode.
  * The thread-local quarantine uses lots of RAM (otherwise the bugs will not be caught).
  * The current implementation of thread-local heap (fake stack) uses a linked list for FIFI and causes a cache miss on every Pop. This can probably be improved.

TODO: get fresh numbers from e.g. SPEC.

=Compatibility=
The fake stack may be incompatible with some low-level code that 
uses certain assumptions about the stack memory layout.
  * Code that takes an address of a local variable and assumes the variable is localed on the real stack.
  * TODO

TODO
