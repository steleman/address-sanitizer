#summary How to build and run AddressSanitizer on Android

== Android platform workflow ==

AddressSanitizer is fully supported in AOSP starting with JellyBean release. To run applications built with ASan you'll need an -eng build of Android.

To build any part of Android system with ASan, add LOCAL_ADDRESS_SANITIZER:=true to the appropriate Android.mk.

To run a standalone native binary, prefix it with asanwrapper: `/system/bin/asanwrapper _path_to_your_binary_ _options_`

NOTE: if you get an assertion failure about INTERCEPT(something), this means ASan interceptors have not kicked in. Verify that you are running the program with asanwrapper.


== Android NDK workflow ==

Grab Android SDK and NDK from the internet.

Then do one of the following:
  * (make build) Read http://src.chromium.org/viewvc/chrome/trunk/src/tools/clang/scripts/update.sh?revision=HEAD&view=markup and do the same (search for "android"). 
  * (cmake build) Read https://code.google.com/p/address-sanitizer/source/browse/trunk/build/scripts/slave/buildbot_cmake.sh and do the same (search for "ANDROID"). 

Either of the above will get you Clang with arm-android ASan runtime library. Cmake build (the second bullet) will also build ASan tests for Android and put asan_device_setup binary under bin/.

Find the GCC-based ARM toolchain in `<ndk>/toolchains/arm-linux-androideabi-4.4.3`, and copy Clang build over it:
{{{
cp Release+Asserts/bin/clang $TOOLCHAIN/prebuilt/linux-x86/bin/
cp -r Release+Asserts/lib/clang $TOOLCHAIN/prebuilt/linux-x86/lib/
ln -sf clang $TOOLCHAIN/prebuilt/linux-x86/bin/arm-linux-androideabi-gcc
ln -sf clang $TOOLCHAIN/prebuilt/linux-x86/bin/arm-linux-androideabi-g++
}}}

And that's all! Now ndk-build will use Clang for "armeabi" and
"armeabi-v7a" platforms.

It is also possible to do this without copying Clang with a set of --sysroot and -B flags.

If you choose to keep the original toolchain, ndk-build has a handy
switch NDK_TOOLCHAIN= (ex., NDK_TOOLCHAIN=arm-linux-androideabi-4.4.3)
to pick one or the other.

With Clang-based toolchain, add the following to your Android.mk to enable ASan:
{{{
LOCAL_CFLAGS += -fsanitize=address
LOCAL_LDFLAGS += -fsanitize=address
}}}


== Running NDK applications with ASan ==

The "old" way (see below) adds a huge (10-20s) delay at the start of any ASan process, because the entire VM needs to be restarted and set up from scratch in order to preload the ASan runtime library. The new way, described in this section, is superior in most respects, except for slightly higher memory usage.

 * No need to set system properties for every app you want to run with ASan.
 * -eng build is not required. -userdebug works perfectly well. Even -user would work if you somehow can edit /system partition (ex. by patching the system image before flashing it to the device).
 * No startup delay. Applications start almost instantly (at the usual 2x slowdown compared to native run).

Drawbacks:
 * One-time device setup step is required. It can be repeated to update ASan runtime library.
 * Slightly higher memory usage in all VM processes. We've observed +85Mb used memory after reboot (20% increase).
 * At the moment there are issues with using logwrapper on ASan processes, which makes reading ASan reports problematic. This will be fixed one way or the other.

The idea is to preload ASan runtime library into *zygote* process. This way, all VM processes run ASan. To not run out of memory right away, we tune down ASan allocator to the absolute minimum by reducing redzones, disabling quarantine, heap poisoning and allocation stack traces. All these features are re-enabled automatically when zygote forks to specialize into your application, and dlopens the first ASan-instrumented library.

This behavior is enabled with ASAN_OPTIONS=start_deactivated=1.

A [http://llvm.org/viewvc/llvm-project/compiler-rt/trunk/lib/asan/scripts/asan_device_setup?view=markup script] can be used to prepare device to run ASan applications. You may need to pass --lib option if it fails to find ASan runtime library.

This script replaces zygote with a wrapper script that preloads ASan runtime library into the process. As a result, ASan packages (.apk) simply work. The script also installs a wrapper in /system/bin/asanwrapper to run ASan binaries.


== Getting good stack traces ==

AddressSanitizer relies on frame pointers to get stack trace in malloc() and other interceptors. To work properly, this requires
`-marm -fno-omit-frame-pointer`.

Alternatively, pass `--extra_options=fast_unwind_on_malloc=0` to asan_device_setup.sh. This will enable dwarf-based unwinder for allocation stack traces, which is more reliable, but very slow. It would be wise to also pass something like `malloc_context_size=3`.

== Running NDK applications with ASan (old way) ==

Copy libclang_rt.asan-arm-android.so (in Clang library directory) somewhere on the device.

Preload it into Dalvik VM by setting the wrap._program_name_ system property as detailed below.

`adb shell setprop wrap._name_ _wrapper_` will spawn a new Dalvik process (fork+exec) for any instance of a given application, with `_wrapper_` prepended to the command line. System properties on Android are limited in length, so write a script like
{{{
ASAN_OPTIONS=debug=1,verbosity=1 \
LD_LIBRARY_PATH=/data/local/tmp/asan:$LD_LIBRARY_PATH \
LD_PRELOAD=libclang_rt.asan-arm-android.so \
exec $@
}}}
, push it on device beside the runtime library and run `adb shell setprop wrap._name_ /data/local/tmp/asan/asanwrapper.sh`. Then start your program as usual. Reports will be printed to `adb logcat` (you may need to add `logwrapper` to the `setprop` line for that to happen).