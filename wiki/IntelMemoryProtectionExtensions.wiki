#summary Discussion of Intel Memory Protection Extensions (MPX)

*This page is under construction*
<wiki:toc max_depth="1" />

= Introduction =
On July 2013 Intel released documentation on the upcoming instruction set extensions, 
including the Memory Protection Extensions (MPX). Here we will discuss the applicability of MPX for memory error detection. 

=Links=

  * http://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler -- MPX-enabled GCC wiki
  * http://software.intel.com/en-us/articles/using-intel-mpx-with-the-intel-software-development-emulator -- Using the MPX-enabled GCC and SDE (emulator)
  * http://download-software.intel.com/sites/default/files/319433-015.pdf -- Fresh documentation on Intel ISA which includes MPX

=Using SDE=
== Set up ==
Intel documentation is too verbose, here is a very short summary for Linux x86_64: 
  * From https://secure-software.intel.com/en-us/protected-download/267266/144917
    * Get 2013-07-22-mpx-runtime-external-lin.tar.bz2
    * Get sde-external-6.1.0-2013-07-22-lin.tar.bz2
  * From http://software.intel.com/en-us/articles/intel-software-development-emulator : 
    * Get binutils-x86-64-static-avx512-mpx-sha.tar.bz2
    * Get gcc-x86-64-static-avx512-mpx-sha.tar.bz2
  * Extract all archives into $MPX_HOME and set the following environment variables: 
{{{
export MPX_GCC=$MPX_HOME/gcc_x86_64_static_avx512-mpx-sha
export MPX_BINUTILS=$MPX_HOME/binutils_x86_64_static_avx512-mpx-sha
export MPX_RUNTIME_LIB=$MPX_HOME/2013-07-22-mpx-runtime-external-lin
export SDE_KIT=$MPX_HOME/sde-external-6.1.0-2013-07-22-lin
}}}

The compiler is build w/o support for multiarch, so I had to do this: 
{{{
% sudo ln -s  /usr/lib/x86_64-linux-gnu/ /usr/lib64
}}}

==Run==
{{{
% cat global_buffer_overflow.c 
#include <stdio.h>
int g[10];
int main(int argc, char **argv) {
  printf("g: %p %p\n", g, g+10);
  int x = g[argc * 10];
  printf("finishing\n");
  return x;
}
% $MPX_GCC/bin/gcc -fmpx -L$MPX_RUNTIME_LIB -B$MPX_BINUTILS/bin -lmpx-runtime64 -Wl,-rpath,$MPX_RUNTIME_LIB global_buffer_overflow.c
# Use CHKP_RT_MODE=count to continue running after bug reports
% CHKP_RT_MODE=count $SDE_KIT/sde -mpx-mode -- ./a.out
g: 0x600bb0 0x600bd8
Bound violation detected,status 0x1 at 0x4006ce
finishing
}}}


I was able to build 401.bzip2 benchmark using this command line: 

{{{
$MPX_GCC/bin/gcc -fmpx -L$MPX_RUNTIME_LIB -B$MPX_BINUTILS/bin -lmpx-runtime64\ 
 -Wl,-rpath,$MPX_RUNTIME_LIB *.c -w -DSPEC_CPU -DNDEBUG -DSPEC_CPU_LP64  \
 -fno-mpx-use-fast-string-functions -fno-mpx-use-nochk-string-functions  -O1
}}}

The emulator ($SDE_KIT/sde) is a PIN-based tool and has ~30x slowdown.

=Performance=
MPX has several different instructions that have very different performance properties: 
  * BNDCU/BNDCL/BNDMK -- pure arithmetic, supposedly very fast
  * BNDMOV -- move the BNDx registers from/to memory, mostly used to spill/fill registers. When accessing memory on stack should hit the L1 cache and thus be fast.
  * BNDLDX/BNDSTX -- access the Bound Table, a 2-layer cache-like data structure. Supposedly very slow (accesses two difference cache like).

Every memory access that needs to be checked will be instrumented with BNDCU/BNDCL (compiler optimizations may apply). 
Since BNDCU/BNDCL are expected to be very fast, the slowdown will be defined by the ratio of number of executed BNDCU/BNDCL vs BNDLDX/BNDSTX.

Unfortunately, the SDE does not seem to allow to collect the statistics in an efficient way. 
The only way to gather statistics from SDE we found is to dump the entire trace:
{{{
time $SDE_KIT/sde -ompx_trace trace.txt -mpx_trace_ins all  -mpx-mode -- ./a.out ...
}}}
We are waiting for Intel to release a version of SDE which will provide the statistics with a reasonable speed. 

So far, we've collected stats on 401.bzip2 startup. At the very beginning the stats looks like this:
{{{
 232622 BNDMK
 267373 BNDSTX
1482635 BNDMOV
2134686 BNDLDX
2941285 BNDCL
2941397 BNDCU
}}}
In other words, we execute one BNDLDX for every BNDCL. This should be very slow. 

However, as the process runs longer we see another picture: 
{{{
 450521  BNDMK
 512036  BNDSTX
4086445  BNDLDX
5173580  BNDMOV
44887291 BNDCL
44890125 BNDCU
}}}
Here, we see one BNDLDX for every ten BNDCLs, which is much better. 

Once we have SDE with reasonable statistics switch, we will gather stats for complete runs of all SPEC benchmarks. 

=False positives=
  * http://software.intel.com/en-us/forums/topic/413959
  * http://software.intel.com/en-us/forums/topic/413960