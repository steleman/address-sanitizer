#summary AddressSanitizer: a fast memory error detector

<wiki:toc max_depth="2" />

*New*: AddressSanitizer [http://llvm.org/releases/3.1/docs/ReleaseNotes.html#whatsnew is released] as part of [http://llvm.org LLVM] 3.1. <BR>
*New*: Watch the presentation from the [http://llvm.org/devmtg/2011-11/ LLVM Developer's meeting] (Nov 18, 2011): [http://www.youtube.com/watch?v=CPnRS1nv3_s Video], [http://llvm.org/devmtg/2011-11/Serebryany_FindingRacesMemoryErrors.pdf slides].<BR>
*New*: Read the [http://research.google.com/pubs/pub37752.html USENIX ATC '2012 paper]. <BR>


=Introduction=

AddressSanitizer (aka ASan) is a memory error detector for C/C++.
It finds:
  * [ExampleUseAfterFree Use after free] (dangling pointer dereference)
  * [ExampleHeapOutOfBounds Heap buffer overflow]
  * [ExampleStackOutOfBounds Stack buffer overflow]
  * [ExampleGlobalOutOfBounds Global buffer overflow]
  * [ExampleUseAfterReturn Use after return]

This tool is very fast. The average slowdown of the instrumented program is ~2x (see PerformanceNumbers).

The tool consists of a compiler instrumentation module (currently, an LLVM pass)
and a run-time library which replaces the `malloc` function.

The tool works on x86 Linux and Mac.

See also:
  * AddressSanitizerAlgorithm -- if you are curious how it works.
  * ComparisonOfMemoryTools

=Getting !AddressSanitizer=

AddressSanitizer is a part of LLVM starting with version 3.1 and will be a part of GCC starting with version 4.8 <BR>
You can download pre-built Clang/LLVM binaries from http://llvm.org/releases/

The Chromium team periodically bakes fresh LLVM/Clang binaries, which include AddressSanitizer support. 
Simply execute the following:
{{{
mkdir -p tools/clang
cd tools/clang
svn co http://src.chromium.org/svn/trunk/src/tools/clang/scripts
cd ../../
tools/clang/scripts/update.sh
# Now use third_party/llvm-build/Release+Asserts/bin/{clang,clang++}
}}}

So far, AddressSanitizer has been tested only on Linux Ubuntu 10.04, 64-bit
(it can run both 64- and 32-bit programs) and Mac 10.6, 10.7 and 10.8.

If you want to build AddressSanitizer yourself, refer to HowToBuild.

= Using !AddressSanitizer =
In order to use AddressSanitizer you will need to compile and link your program using `clang` with the `-fsanitize=address` switch. <BR>
To get a reasonable performance add `-O1` or higher. <BR>
To get nicer stack traces in error messages add `-fno-omit-frame-pointer`. <BR>
Note: [http://llvm.org/releases/3.1/tools/clang/docs/AddressSanitizer.html Clang 3.1 release uses another flag syntax].

{{{
% cat tests/use-after-free.c
#include <stdlib.h>
int main() {
  char *x = (char*)malloc(10 * sizeof(char*));
  free(x);
  return x[5];
}
% ../clang_build_Linux/Release+Asserts/bin/clang -fsanitize=address -O1 -fno-omit-frame-pointer -g   tests/use-after-free.c
}}}

Now, run the executable.

{{{
% ./a.out
==22420== ERROR: AddressSanitizer crashed on address 0x0000200000703c18 at pc 0x401947
READ of size 1 at 0x0000200000703c18; shadow: 0x0000100000381e0c; mem: 0x0000000001c0f065 thread: 0x787d4720
    #0 0x401947 main use-after-free.c:5
    #1 0x7ff87792cc4d __libc_start_main ??:0
    #2 0x401839 _start ??:0
0x0000000001c0f065 is located 5 bytes inside of 80-byte region [0x0000000001c0f060,0x0000000001c0f0b0)
freed by thread 0x787d4720 here:
    #0 0x404b9b free asan_rtl.cc:1203
    #1 0x40191b main use-after-free.c:5
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
previously allocated by thread 0x787d4720 here:
    #0 0x405c27 malloc asan_rtl.cc:1196
    #1 0x401910 main use-after-free.c:3
    #2 0x7ff87792cc4d __libc_start_main ??:0
    #3 0x401839 _start ??:0
}}}

=Interaction with other tools=
==gdb==
You can use [http://www.gnu.org/software/gdb/ gdb] with
binaries built by AddressSanitizer in a usual way.
When AddressSanitizer finds a bug it calls one of the functions `__asan_report_{load,store}{1,2,4,8,16}`
which in turn calls `__asan_report_error`.
If you want gdb to stop before asan reports an error, set a breakpoint on `__asan_report_error`.

However, please note, that there are [https://code.google.com/p/address-sanitizer/issues/detail?id=41 bugs]
in the DWARF support in Clang/AddressSanitizer.


==ulimit -v==
The `ulimit -v` command can be used with ASan-ified binaries.
However, you should remember that ASan consumes 16 terabytes of virtual memory for shadow state and the `ulimit -v` value should be set accordingly.
For example, the following script may be used as a wrapper for `ulimit -v`:
{{{
#!/bin/bash
LIMIT_IN_GIGABYTES=$1
shift
# The value to pass to ulimit is 2^44+$LIMIT_IN_GIGABYTES bytes
ASAN_LIMIT=$(echo "(2^44 + $LIMIT_IN_GIGABYTES * 2^30) / 2^10" | bc -q)
echo ASAN_LIMIT: $ASAN_LIMIT
ulimit -v $ASAN_LIMIT
"$@"
}}}


=Flags=

Compile-time flags are passed via clang flag `-mllvm <flag>`.
|| flag|| default || description ||
|| -asan-stack   || 1 || Detect overflow/underflow for stack objects ||
|| -asan-globals || 1 || Detect overflow/underflow for global objects (see [KnownBugs])   ||
|| -asan-blacklist ||  || Pass a [#BlackList_file blacklist file] ||


Most run-time flags are passed to AddressSanitizer via `ASAN_OPTIONS` environment variable like this: 
{{{
ASAN_OPTIONS=verbosity=1 ./a.out
}}}

|| flag|| default || description ||
|| verbosity  || 0 || Be more verbose (mostly for testing the tool itself) ||
|| malloc_context_size || 30 || Number of frames in `malloc`/`free` stack traces. Valid values are 0...256. Note: for large sizes to work you may also need to increase the redzone to 256 or 512 ||
|| redzone || 128 || Size of the redzone. Valid values are 32, 64, 128, ..., 4096 ||
|| log_path|| <none> || Path to the log files. If log_path=PATH is given, every process will write error reports to PATH.PID. By default all reports are written to stderr. ||
|| sleep_before_dying || 0 || Sleep for this number of seconds before exiting the process on failure. ||
|| || || ||

=Call stack=
AddressSanitizer collects call stacks on the following events:
  * `malloc` and `free`
  * thread creation
  * failure

`malloc` and `free` happen relatively frequently and it is important to unwind the call stack fast.
AddressSanitizer uses a simple unwinder that relies on frame pointers.

If you don't care about `malloc`/`free` call stacks, simply disable the unwinder completely
(`malloc_context_size=0`).

Each stack frame needs to be symbolized (of course, if the binary is compiled with debug info).
Given a PC, we need to print
{{{
  #0xabcdf function_name file_name.cc:1234
}}}
<wiki:comment>
[http://llvm.org/bugs/show_bug.cgi?id=7554 LLVM issue].
</wiki:comment>
Currently, AddressSanitizer does not have an in-process symbolizer.
You will need to filter the log file through `scripts/asan_symbolize.py` to get the symbols.
This script takes an optional parameter -- a file prefix.
The substring `.*prefix` will be removed from the file names.
{{{
% ./a.out
    ...
    #0 0x402c77 (/home/you/address-sanitizer/asan/a.out+0x402c77)
    ...
% ./a.out 2>&1  | ../scripts/asan_symbolize.py
   ...
   #0 0x402c77 in main /home/you/address-sanitizer/asan/use-after-free.c:5
   ...
% ./a.out 2>&1  | ../scripts/asan_symbolize.py /you/
   ...
   #0 0x402c77 in main address-sanitizer/asan/use-after-free.c:5
   ...
}}}
There is also an out-of-process symbolizer based on LLVM libraries (currently under development) that can be run by AddressSanitizer in a separate subprocess and symbolize stack traces online. If you have
a [http://code.google.com/p/address-sanitizer/wiki/HowToBuild cmake build of LLVM] and compiler-rt, you can build this symbolizer:
{{{
cd /path/to/llvm_cmake_build/projects/compiler-rt/utils/llvm-symbolizer
make
SYMBOLIZER_PATH=`pwd`/llvm-symbolizer
}}}
You may use it in ASan in the following manner:
{{{
export ASAN_SYMBOLIZER_PATH=${SYMBOLIZER_PATH}
ASAN_OPTIONS=symbolize=1 ./a.out
}}}

=Blacklist file=
In some cases a particular function should be ignored (not instrumented) by AddressSanitizer.
One of the reasons is speed (e.g. a hot function known to be correct).
Another reason is to avoid reporting known problems.

To ignore certain functions, create a file `my_ignores.txt` and pass it to AddressSanitizer
at compile time using `-mllvm -asan-blacklist=my_ignores.txt`:
{{{
# Ignore exactly this function (the names are mangled)
fun:MyFooBar
# Ignore MyFooBar(void) if it is in C++:
fun:_Z8MyFooBarv
# Ignore all function containing MyFooBar
fun:*MyFooBar*
}}}

=FAQ=
  * Q: Can AddressSanitizer continue running after reporting first error? 
  * A: No, sorry. AddressSanitizer errors are fatal. This design choice allows the tool to be faster and simpler. 

=Comments?=
Send comments to address-sanitizer@googlegroups.com 
or [https://plus.google.com/117014197169958493500 in Google+].

<g:plusone></g:plusone>